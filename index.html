import React, { useState, useEffect, useMemo } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, onSnapshot, updateDoc, setDoc, arrayUnion, arrayRemove } from 'firebase/firestore';
import { LogOut, Plus, Trash2, Edit2, Check, X, Users, Zap, Hash, ChevronsUp, ChevronsDown, Minus } from 'lucide-react';

// --- MOCK DATA & CONFIG ---
// Global variables provided by the Canvas environment
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// Mock data for Swarms to populate the dropdown
const MOCK_SWARMS = [
  { id: 'hgaunts', name: 'Hormagaunts', points: 50, traits: 'Horde, Melee' },
  { id: 'tgaunts', name: 'Termagants', points: 55, traits: 'Horde, Ranged' },
  { id: 'gargoyles', name: 'Gargoyles', points: 60, pointsPerModel: 12, traits: 'Fly, Fast' },
  { id: 'lictor', name: 'Lictor', pointsPerModel: 75, traits: 'Infiltrate, Stealth' },
  { id: 'warrior', name: 'Tyranid Warrior', pointsPerModel: 20, traits: 'Synapse, Durable' },
];

const swarmTypeToIcon = (type) => {
  switch (type) {
    case 'hgaunts': return <Zap className="w-4 h-4 text-pink-500" />;
    case 'tgaunts': return <Hash className="w-4 h-4 text-blue-500" />;
    case 'gargoyles': return <ChevronsUp className="w-4 h-4 text-green-500" />;
    case 'lictor': return <Users className="w-4 h-4 text-red-500" />;
    case 'warrior': return <ChevronsDown className="w-4 h-4 text-purple-500" />;
    default: return <Plus className="w-4 h-4 text-gray-400" />;
  }
};

const getModelPoints = (typeId) => {
    // Finds the base points per model. If not specified, calculates based on a default squad size of 5 for MOCK_SWARMS base points.
    const swarm = MOCK_SWARMS.find(s => s.id === typeId);
    // Use pointsPerModel if available, otherwise default to a calculated value or 10.
    return swarm?.pointsPerModel || Math.ceil(swarm?.points / 5) || 10;
};

// --- FIREBASE INITIALIZATION & STATE ---
function App() {
  const [db, setDb] = useState(null);
  const [auth, setAuth] = useState(null);
  const [userId, setUserId] = useState(null);
  const [isAuthReady, setIsAuthReady] = useState(false);

  // Brood State
  const [brood, setBrood] = useState(null);
  const [broodName, setBroodName] = useState('');
  const [isEditingName, setIsEditingName] = useState(false);

  // New Swarm State (User Request)
  const [selectedSwarmId, setSelectedSwarmId] = useState('');

  // UI State
  const [loading, setLoading] = useState(true);
  const [snackbarMessage, setSnackbarMessage] = useState(null);

  // Firebase Initialization and Authentication
  useEffect(() => {
    if (!firebaseConfig) {
      console.error("Firebase config is missing.");
      setLoading(false);
      return;
    }

    try {
      const app = initializeApp(firebaseConfig);
      const firestore = getFirestore(app);
      const firebaseAuth = getAuth(app);

      setDb(firestore);
      setAuth(firebaseAuth);

      const unsubscribe = onAuthStateChanged(firebaseAuth, async (user) => {
        if (!user) {
          try {
            if (initialAuthToken) {
              await signInWithCustomToken(firebaseAuth, initialAuthToken);
            } else {
              await signInAnonymously(firebaseAuth);
            }
          } catch (error) {
            console.error("Authentication error:", error);
          }
        }
        setUserId(firebaseAuth.currentUser?.uid || 'anonymous');
        setIsAuthReady(true);
      });

      return () => unsubscribe();
    } catch (error) {
      console.error("Error initializing Firebase:", error);
      setLoading(false);
    }
  }, []);

  // Firestore Data Listener
  useEffect(() => {
    if (!isAuthReady || !db || !userId) return;

    // Use a fixed Brood ID for simplicity in this single-user app structure
    const broodId = 'my-hive-fleet-brood';
    // Path: /artifacts/{appId}/users/{userId}/broods/{broodId}
    const broodDocRef = doc(db, `artifacts/${appId}/users/${userId}/broods`, broodId);

    const unsubscribe = onSnapshot(broodDocRef, (docSnap) => {
      if (docSnap.exists()) {
        const data = docSnap.data();
        setBrood(data);
        setBroodName(data.name || 'New Brood');
      } else {
        // Create initial brood document if it doesn't exist
        setBrood(null);
        setBroodName('New Brood');
        // Will be created on first save/add
      }
      setLoading(false);
    }, (error) => {
      console.error("Error fetching brood data:", error);
      setLoading(false);
      setSnackbarMessage({ text: 'Failed to load data. Check console for details.', type: 'error' });
    });

    return () => unsubscribe();
  }, [isAuthReady, db, userId, appId]);

  // --- HANDLERS ---

  const createOrUpdateBrood = async (updateData) => {
    if (!db || !userId || !isAuthReady) return;
    const broodId = 'my-hive-fleet-brood';
    const broodDocRef = doc(db, `artifacts/${appId}/users/${userId}/broods`, broodId);

    const baseData = {
        name: broodName,
        swarms: brood?.swarms || [],
        createdAt: brood?.createdAt || new Date().toISOString(),
        updatedAt: new Date().toISOString(),
    };

    try {
        if (!brood) {
            // Document creation (setDoc with merge: true for safety)
            await setDoc(broodDocRef, { ...baseData, ...updateData }, { merge: true });
        } else {
            // Document update
            await updateDoc(broodDocRef, updateData);
        }
        return true;
    } catch (error) {
        console.error("Error updating brood:", error);
        setSnackbarMessage({ text: 'Failed to save changes. Please try again.', type: 'error' });
        return false;
    }
  };

  const handleNameSave = async () => {
    if (!broodName.trim()) {
      setSnackbarMessage({ text: 'Brood name cannot be empty.', type: 'error' });
      return;
    }
    const success = await createOrUpdateBrood({ name: broodName.trim() });
    if (success) setIsEditingName(false);
  };

  const handleAddSwarm = async () => {
    if (!db || !userId) return;

    if (!selectedSwarmId) {
        setSnackbarMessage({ text: 'Please select a Swarm type first.', type: 'error' });
        return;
    }

    const swarmData = MOCK_SWARMS.find(s => s.id === selectedSwarmId);
    if (!swarmData) {
        setSnackbarMessage({ text: 'Invalid Swarm type selected.', type: 'error' });
        return;
    }

    const newSwarm = {
        id: crypto.randomUUID(), // Unique ID for this instance
        typeId: swarmData.id,
        name: swarmData.name,
        // Using pointsPerModel for accurate calculation, falling back to base points for display/initial logic
        points: swarmData.points || swarmData.pointsPerModel * 5, 
        traits: swarmData.traits,
        size: 5, // Default starting size
        pointsPerModel: getModelPoints(swarmData.id) // Calculate and store points per model
    };

    const success = await createOrUpdateBrood({ swarms: arrayUnion(newSwarm) });
    if (success) {
        // Clear the dropdown after adding
        setSelectedSwarmId('');
        setSnackbarMessage({ text: `${swarmData.name} added successfully!`, type: 'success' });
    }
  };

  const handleDeleteSwarm = async (swarmId) => {
    if (!brood) return;

    const swarmToRemove = brood.swarms.find(s => s.id === swarmId);
    if (!swarmToRemove) return;

    const success = await createOrUpdateBrood({ swarms: arrayRemove(swarmToRemove) });
    if (success) {
        setSnackbarMessage({ text: `${swarmToRemove.name} removed.`, type: 'info' });
    }
  };

  const handleSizeChange = async (swarmId, delta) => {
    if (!brood) return;

    const updatedSwarms = brood.swarms.map(s => {
      if (s.id === swarmId) {
        const newSize = Math.max(0, s.size + delta); // Min size 0
        return { ...s, size: newSize };
      }
      return s;
    }).filter(s => s.size > 0); // Remove swarm if size hits zero

    // Only update if the list is different (i.e., size changed or swarm was removed)
    if (JSON.stringify(updatedSwarms) !== JSON.stringify(brood.swarms)) {
        const success = await createOrUpdateBrood({ swarms: updatedSwarms });
        if (success) {
            if (updatedSwarms.length < brood.swarms.length) {
                 setSnackbarMessage({ text: `Swarm removed as size reached 0.`, type: 'info' });
            }
        }
    }
  };

  // --- CALCULATED VALUES ---

  const totalBroodPoints = useMemo(() => {
    if (!brood?.swarms) return 0;
    return brood.swarms.reduce((total, swarm) => {
      // Points calculation: Points Per Model * current size
      // Use the stored pointsPerModel value
      const pointsPerModel = swarm.pointsPerModel; 
      return total + (pointsPerModel * swarm.size);
    }, 0);
  }, [brood]);


  // --- UI COMPONENTS ---

  const Snackbar = ({ message, type }) => {
    useEffect(() => {
      if (message) {
        const timer = setTimeout(() => setSnackbarMessage(null), 3000);
        return () => clearTimeout(timer);
      }
    }, [message]);

    if (!message) return null;

    const baseStyle = "fixed bottom-5 left-1/2 transform -translate-x-1/2 px-6 py-3 rounded-full shadow-2xl text-white font-semibold transition-opacity duration-300 z-50";
    const typeStyle = type === 'error' ? 'bg-red-600' : type === 'success' ? 'bg-green-600' : 'bg-indigo-600';

    return (
      <div className={`${baseStyle} ${typeStyle}`}>
        {message.text}
      </div>
    );
  };

  const BroodCard = ({ swarm }) => {
      // Calculate points for this specific card using the stored value (minor clarity update)
      const pointsPerModel = swarm.pointsPerModel; 
      const cardPoints = pointsPerModel * swarm.size;

    return (
      <div className="bg-white p-4 rounded-xl shadow-lg flex flex-col sm:flex-row items-start sm:items-center justify-between transition duration-300 hover:shadow-xl border border-gray-100">
        <div className="flex items-center gap-3 mb-3 sm:mb-0">
          <div className="p-2 bg-gray-100 rounded-full flex-shrink-0">
            {swarmTypeToIcon(swarm.typeId)}
          </div>
          <div>
            <div className="text-lg font-bold text-gray-800">{swarm.name}</div>
            <div className="text-sm text-gray-500 font-mono italic">{swarm.traits}</div>
          </div>
        </div>

        <div className="flex items-center gap-4">
            {/* Size Control */}
            <div className="flex items-center space-x-2 bg-gray-50 p-2 rounded-lg border border-gray-200">
                <button
                    onClick={() => handleSizeChange(swarm.id, -1)}
                    className="p-1 bg-red-100 text-red-600 rounded-full hover:bg-red-200 transition disabled:opacity-30"
                    disabled={swarm.size <= 0}
                    title="Decrease Size by 1 (Min 0)"
                >
                    <Minus className="w-4 h-4" />
                </button>
                <span className="text-base font-semibold text-gray-700 w-10 text-center">Size: {swarm.size}</span>
                <button
                    onClick={() => handleSizeChange(swarm.id, 1)}
                    className="p-1 bg-green-100 text-green-600 rounded-full hover:bg-green-200 transition"
                    title="Increase Size by 1"
                >
                    <Plus className="w-4 h-4" />
                </button>
            </div>

            {/* Points and Delete */}
            <div className="text-lg font-bold text-indigo-600 mr-2 min-w-[70px] text-right">{cardPoints} pts</div>
            <button
              onClick={() => handleDeleteSwarm(swarm.id)}
              className="p-2 bg-red-500 text-white rounded-full hover:bg-red-600 transition shadow-md flex-shrink-0"
              title="Remove Swarm"
            >
              <Trash2 className="w-5 h-5" />
            </button>
        </div>
      </div>
    );
  };


  if (loading || !isAuthReady) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-2xl font-semibold text-indigo-600 animate-pulse">Loading Hive Fleet Data...</div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 p-4 sm:p-8 font-[Inter]">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-4xl font-extrabold text-gray-900 mb-2 flex items-center">
          <img src="https://placehold.co/40x40/500096/ffffff?text=H" onError={(e)=>{e.target.onerror=null; e.target.src='https://placehold.co/40x40/500096/ffffff?text=H'}} alt="Hive Icon" className="mr-3 rounded-md" />
          Hive War Brood Builder
        </h1>
        <p className="text-gray-500 mb-6">User ID: <span className='font-mono text-xs break-all'>{userId}</span></p>

        {/* --- TOP SECTION: Brood Info & Swarm Addition --- */}
        <div className="bg-white p-5 shadow-2xl rounded-xl border-4 border-indigo-600 mb-8">
            <h2 className="text-xl font-bold text-gray-800 mb-4 border-b pb-2">Brood Configuration</h2>

            {/* Row 1: Brood Name and Points */}
            <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4 mb-4">
                <div className="flex items-center flex-grow">
                    {isEditingName ? (
                        <>
                            <input
                                type="text"
                                value={broodName}
                                onChange={(e) => setBroodName(e.target.value)}
                                className="flex-grow p-2 border border-indigo-300 rounded-l-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 text-lg font-semibold"
                            />
                            <button
                                onClick={handleNameSave}
                                className="p-2 bg-green-500 text-white rounded-r-lg hover:bg-green-600 transition"
                                title="Save Name"
                            >
                                <Check className="w-6 h-6" />
                            </button>
                            <button
                                onClick={() => { setIsEditingName(false); setBroodName(brood?.name || 'New Brood'); }}
                                className="p-2 bg-gray-500 text-white ml-2 rounded-lg hover:bg-gray-600 transition"
                                title="Cancel Edit"
                            >
                                <X className="w-6 h-6" />
                            </button>
                        </>
                    ) : (
                        <div className="flex items-center">
                            <span className="text-2xl font-bold text-gray-900 mr-3">{broodName}</span>
                            <button
                                onClick={() => setIsEditingName(true)}
                                className="p-1 bg-indigo-100 text-indigo-600 rounded-full hover:bg-indigo-200 transition"
                                title="Edit Name"
                            >
                                <Edit2 className="w-5 h-5" />
                            </button>
                        </div>
                    )}
                </div>
                <div className="flex-shrink-0 text-2xl font-extrabold text-indigo-700 bg-indigo-50 px-4 py-2 rounded-xl border border-indigo-300">
                    Total Points: <span className="font-mono">{totalBroodPoints}</span>
                </div>
            </div>

            {/* Row 2: Swarm Selection and Add Button */}
            <div className="flex flex-col sm:flex-row gap-4 items-stretch pt-4 border-t border-gray-100">
                <select
                    value={selectedSwarmId}
                    onChange={(e) => setSelectedSwarmId(e.target.value)}
                    className="flex-grow p-3 border border-gray-300 rounded-lg bg-white text-gray-700 focus:ring-indigo-500 focus:border-indigo-500 transition duration-150"
                >
                    <option value="" disabled>Select Swarm Type to Add...</option>
                    {MOCK_SWARMS.map(swarm => (
                        <option key={swarm.id} value={swarm.id}>
                            {swarm.name} ({getModelPoints(swarm.id)} pts/model) - {swarm.traits}
                        </option>
                    ))}
                </select>

                <button
                    onClick={handleAddSwarm}
                    disabled={!selectedSwarmId}
                    className="flex-shrink-0 flex items-center justify-center gap-2 px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed shadow-lg"
                >
                    <Plus className="w-5 h-5" />
                    Add Swarm
                </button>
            </div>
        </div>


        {/* --- SWARM LIST --- */}
        <h2 className="text-3xl font-bold text-gray-800 mb-4">Brood Swarms ({brood?.swarms?.length || 0})</h2>

        <div className="space-y-4">
          {brood?.swarms && brood.swarms.length > 0 ? (
            brood.swarms.map(swarm => (
              <BroodCard key={swarm.id} swarm={swarm} />
            ))
          ) : (
            <div className="text-center p-10 bg-white rounded-xl border-dashed border-2 border-gray-300 text-gray-500">
              <Zap className='w-10 h-10 mx-auto mb-4 text-gray-400' />
              <p className='text-lg font-medium'>Your Brood is empty.</p>
              <p>Add a Swarm using the selector above!</p>
            </div>
          )}
        </div>

      </div>
      <Snackbar message={snackbarMessage} type={snackbarMessage?.type} />
    </div>
  );
}

export default App;
